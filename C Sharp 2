1. Delegate vs Event
An Event declaration adds a layer of abstraction and protection on the delegate instance. 
This protection prevents clients of the delegate from resetting the delegate and 
its invocation list and only allows adding or removing targets from the invocation list.

Explanation:
Delegates support ‘=’ assignment operator, events do not.
If you write your system with just delegate, the consumer may use ‘=’ operator to attach method without error. 
Now what issue this would introduce? As we said, the event can be subscribed by many components, so if we want to use delegates we must use ‘+=’ to support many methods. 
Suppose, someone forgets to use ‘+=’ and uses ‘=’, he will unknowingly detach all attached methods and attach only his method. 
This will be a big mess as other components will never receive event notification.


2. Static class vs Singleton
Instantiation: Static classes cannot be instantiated, whereas singletons are instantiated but restrict the creation of additional instances.
Access: Static class members are accessed directly using the class name, while singleton instances are accessed through a specific method or property.
Inheritance: Static classes cannot be inherited or overridden, while singletons can be extended by subclasses and implement interfaces.
State: Static classes do not maintain a state, whereas singletons can have state. However, it is important to be cautious with mutable state in singletons, as it can lead to potential concurrency issues.
Flexibility: Singletons offer more flexibility due to their ability to implement interfaces and be extended, while static classes are limited to containing static members only.

3. Ref vs Out

4. String vs String Builder

5. Thread vs Task

6. Concarant vs Parallel

7. == vs Equales

8. Array vs ArrayList

9. Encapsulation vs Interface

10. Collection vs Generic

11. Struct vs Class

12. Filter vs Middleware

13. Property vs Variable

14. Throw vs Throw ex

15. Real-time example of when to use abstract class and interfere

16. shallow copy vs deep copy

17. Use of asynchronous programming

18. Thread polling

19. WaitAll vs WhenAll

20. Async method vs method

21. Deadlock in thread

22. Thread states

23. How to use abstraction in c#

