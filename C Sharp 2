1. Delegate vs Event
An Event declaration adds a layer of abstraction and protection on the delegate instance. 
This protection prevents clients of the delegate from resetting the delegate and 
its invocation list and only allows adding or removing targets from the invocation list.

Explanation:
Delegates support ‘=’ assignment operator, events do not.
If you write your system with just delegate, the consumer may use ‘=’ operator to attach method without error. 
In case when the event is subscribed by many components or clients, they will use ‘+=’ to support many methods. 
Suppose, someone forgets to use ‘+=’ and uses ‘=’, he will unknowingly detach all attached methods and attach only his method. 
This will be a big mess as other components will never receive event notification.


2. Static class vs Singleton
Instantiation: Static classes cannot be instantiated, whereas singletons are instantiated but restrict the creation of additional instances.
Access: Static class members are accessed directly using the class name, while singleton instances are accessed through a specific method or property.
Inheritance: Static classes cannot be inherited or overridden, while singletons can be extended by subclasses and implement interfaces.
State: Static classes do not maintain a state, whereas singletons can have state. However, it is important to be cautious with mutable state in singletons, as it can lead to potential concurrency issues.
Flexibility: Singletons offer more flexibility due to their ability to implement interfaces and be extended, while static classes are limited to containing static members only.

3. Ref vs Out
1. The parameter or argument must be initialized first before it is passed to ref.	
It is not compulsory to initialize a parameter or argument before it is passed to an out.

2. It is not compulsory to initialize a parameter value before using it in a calling method.	
A parameter value must be initialized within the calling method before its use.

3. Passing a parameter value by Ref is useful when the called method is also needed to modify the pass parameter.	
Declaring a parameter to an out method is useful when multiple values need to be returned from a function or method.

4. When we use REF, data can be passed bi-directionally.	
When we use OUT data is passed only in a unidirectional way (from the inner method to the outer method).

4. String vs String Builder
The string class in C# is immutable, meaning its value cannot be changed once it is created. 
Every time you modify a string, a new instance is created in memory, which can lead to performance issues when dealing with large or frequently modified strings. 
However, the string class offers several convenient methods for string manipulation, such as concatenation, splitting, and replacing.

The StringBuilder class, on the other hand, is mutable, which means you can modify its value without creating a new instance each time. 
It provides efficient string manipulation by reducing memory allocation and reallocation.

5. Thread vs Task
Tasks in .NET:
Tasks, introduced in the Task Parallel Library (TPL), provide an abstraction for asynchronous operations. 
They represent units of work that can be executed concurrently and allow for efficient utilization of system resources. 
Tasks rely on thread pool threads, which are managed by the runtime, making them lightweight and scalable.

Threads in .NET:
Threads are the fundamental units of execution in a program. 
They allow for concurrent execution of code and can run in parallel on multiple CPU cores. 
Threads have a direct association with operating system threads and require explicit management by the developer.

Differences:
- Abstraction Level: Tasks provide a higher-level abstraction, allowing developers to focus on the work being performed rather than lowe level thread management.
- Resource Utilization: Tasks leverage thread pool threads, which are more efficient in terms of resource allocation and can be dynamically assigned based on the system's load.
- Synchronization: Tasks inherently support synchronization mechanisms like `await` and `ContinueWith` for coordination and handling of dependencies and chain of tasks.
- Flexibility: Threads provide more control and flexibility, allowing direct manipulation of thread priorities, thread-local storage, and explicit thread management.

5. WhenAll vs WaitAll
In case of WhenAll method task execution don't block other tasks. 
But in WaitAll method task blocks and execute all task sequentially. 

WhenAll is parallel means asynchronous execution of all tasks. 
WaitAll is synchronous execution

6. Concarant vs Parallel

7. == vs Equales

8. Array vs ArrayList

9. Encapsulation vs Interface

10. Collection vs Generic

11. Struct vs Class

12. Filter vs Middleware

13. Property vs Variable

14. Throw vs Throw ex

15. Real-time example of when to use abstract class and interfere

16. shallow copy vs deep copy

17. Use of asynchronous programming

18. Thread polling

19. 

20. Async method vs method

21. Deadlock in thread

22. Thread states

23. covariance vs contravariance

24. association vs aggregation

25. stack vs heap

26. How to use abstraction in c#

27. Managed vs Unmanaged code

