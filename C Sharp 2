1. Delegate vs Event
An Event declaration adds a layer of abstraction and protection on the delegate instance. 
This protection prevents clients of the delegate from resetting the delegate and 
its invocation list and only allows adding or removing targets from the invocation list.

Explanation:
Delegates support ‘=’ assignment operator, events do not.
If you write your system with just delegate, the consumer may use ‘=’ operator to attach method without error. 
Now what issue this would introduce? As we said, the event can be subscribed by many components, so if we want to use delegates we must use ‘+=’ to support many methods. 
Suppose, someone forgets to use ‘+=’ and uses ‘=’, he will unknowingly detach all attached methods and attach only his method. 
This will be a big mess as other components will never receive event notification.


2. Static class vs Singleton
Instantiation: Static classes cannot be instantiated, whereas singletons are instantiated but restrict the creation of additional instances.
Access: Static class members are accessed directly using the class name, while singleton instances are accessed through a specific method or property.
Inheritance: Static classes cannot be inherited or overridden, while singletons can be extended by subclasses and implement interfaces.
State: Static classes do not maintain a state, whereas singletons can have state. However, it is important to be cautious with mutable state in singletons, as it can lead to potential concurrency issues.
Flexibility: Singletons offer more flexibility due to their ability to implement interfaces and be extended, while static classes are limited to containing static members only.

3. Ref vs Out
1. The parameter or argument must be initialized first before it is passed to ref.	
It is not compulsory to initialize a parameter or argument before it is passed to an out.

2. It is not compulsory to initialize a parameter value before using it in a calling method.	
A parameter value must be initialized within the calling method before its use.

3. Passing a parameter value by Ref is useful when the called method is also needed to modify the pass parameter.	
Declaring a parameter to an out method is useful when multiple values need to be returned from a function or method.

4. When we use REF, data can be passed bi-directionally.	
When we use OUT data is passed only in a unidirectional way (from the inner method to the outer method).

4. String vs String Builder

5. Thread vs Task

6. Concarant vs Parallel

7. == vs Equales

8. Array vs ArrayList

9. Encapsulation vs Interface

10. Collection vs Generic

11. Struct vs Class

12. Filter vs Middleware

13. Property vs Variable

14. Throw vs Throw ex

15. Real-time example of when to use abstract class and interfere

16. shallow copy vs deep copy

17. Use of asynchronous programming

18. Thread polling

19. WaitAll vs WhenAll

20. Async method vs method

21. Deadlock in thread

22. Thread states

23. How to use abstraction in c#

